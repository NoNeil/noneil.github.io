---
title: C++的150个建议
date: 2019-04-05 22:29:19
updated: 2019-04-05 22:29:19
description: 读书笔记：《编写高质量代码：改善C++程序的150个建议》
categories: C++
tags:
- C++
---

读书笔记，书名：《编写高质量代码：改善C++程序的150个建议》

# 第一部分 语法篇

## 第1章 从C继承而来

### 不要让main返回void
C++03中给出的2种main函数定义方式：
```C++
int main() 
int main( int argc, char *argv[] )
```
在linux中执行`./out && echo "success"`，如果main函数`return -1`，则不会输出"success"
C++中还有个规定，如果main函数中不写return，编译器会隐式地加上`return 0`

### 区分0的4种面孔
1. 整型`0`
2. 空指针NULL，`#define NULL 0`。 C++中空指针被定义为`nullptr`
3. 字符串结束符`'\0'`
4. 逻辑`false`

### == 的正确使用方式
```C++
if (0 == value){
}
```

### 表达式的计算顺序
1. 不确定优先级时，使用括号解决
2. 不确定fun_1()与fun_2()的计算顺序
```C++
printf("The results are: %d %d", fun_1(), fun_2() );
```

### 宏#define的陷阱
1. 使用完备的括号
2. 调用宏定义函数时，不要使参数发生变化
```C++
#define SQUARE( a ) ((a) * (a)) 
int Square(int a) { return a*a; } 

int nValue1 = 10, nValue2 = 10; 
int nSquare1 = SQUARE(nValue1++);   // nSquare1=110, nValue1=12 
int nSquare2 = Square(nValue2++);   // nSquare2=100, nValue2=11
```
3. 用大括号将多条表达式括起来

### 指针必须赋初始化值
如果不赋初值，编译器会初始化一个随机值，这将是很危险的。
```C++
int* p = NULL;
int* q = new int(1);
```

### 逗号分隔符
```C++
表达式1, 表达式2, 表达式3, ..., 表达式n
```
整个逗号分隔表达式的值为`表达式n`的值。

### 时刻提防内存溢出
在处理字符串、数组时，时刻提防内存溢出。

### 拒绝晦涩难懂的函数指针

### 防止重复包含头文件
为了避免同一个文件被包含多次，C/C++中有两种处理方式，一种是#ifndef方式，另一种是#pragma once方式。
**注意：不同的头文件不能使用相同的宏名，否则编译器会报"找不到声明"的错误**
1. 方式1： 
```C++
#ifndef __SOMEFILE_H__
#define __SOMEFILE_H__
// 声明、定义语句 
#endif 
```
2. 方式2：(GCC已经取消支持，Visual Studio还支持)
```C++ 
#pragma once 
// 声明、定义语句
```

### 优化结构体中的元素布局

### 将强制转换减到最少
C++的四种强制转换形式：
1. const_cast<T*> (a)，从类中去除一下属性：const、volatile、__unaligned
2. dynamic_cast<T*> (a)，"类的安全的向下转换"，用于将基类指针转换为派生类指针，基类指针可以指向派生类对象，能实现多态，转换是安全的。
3. reinterpret_cast<T*> (a)，"重新解释"，不相关类型之间的转换，是不安全的
4. static_cast<T*> (a)，相当于传统的C语言里的强制转换，在运行时转换过程中，不进行类型检查，是不安全的
```C++
class Base {
};

class Derived : public Base {
};

int main() {

    Base *pB = new Base();
    if (Derived *pD = static_cast<Derived *>(pB)) {
        // 编译期和运行时不做类型检查
        // 向上转换是不安全的(坚决抵制这种方法)
    }

    Derived *pD = new Derived();
    if (Base *p1 = static_cast<Base *>(pD)) {
        // 向下转换是安全的
    }

    if (Derived *p2 = dynamic_cast<Derived *>(pB)) {
        // 编译期报错，error: 'Base' is not polymorphic
    }
    if (Base *p3 = dynamic_cast<Derived *>(pD)) {
        // 向下转换是安全的
    }
    return 0;
}
```

### 优先使用前缀操作符
后缀操作过程中会构造一个临时对象，因此效率不如前缀操作。
但是，对于整型和长整型而言，性能区别通常可以忽略。另外，编译器一般会对后缀操作符进行优化。

### 掌握变量定义的时机
1. 尽量不在循环内定义变量或实例化对象
2. 尽可能晚、尽可能local

### 小心typedef的陷阱
1. typedef与#define的区别
```C++
typedef int* PTR_INT1
#define PTRINT2
PTR_INT1 pNum1, pNum2;  // pNum2是int*类型
PTR_INT2 pNum3, pNum4;  // nNum4是int类型
```
2. typedef可以定义平台无关的类型，如size_t
3. typedef是一个存储类的关键字，类似于static、mutable、register等

### 尽量不要使用可变参数
可变参数的函数没有类型检查，形式如下：
```C++
int func(int para1, int para2, ...);
```

### 禁用goto

### 小心隐式转换
1. 基本类型之间的隐式转换，要注意精度损失问题。
2. C++中规定T*到void*单向的转换，是安全的。而C中允许双向转换，不安全。
3. 不明确的构造函数，不检查参数类型；转换过程中会调用类的构造函数、析构函数
编译器会隐式地将float类型的fVal转成int，然后调用类A的构造函数。
解决方法：为单参数的构造函数加上explicite关键字。
```C++
class A
{
public:
    A(int x): m_data(x){}
private:
    int m_data;
}
void DoSomething(A a);
float fVal = 1.23f;
DoSomething(fVal);
```
4. 安全的隐式转换：子类到基类的转换、const到non-const的转换

### 正确区分void与void*
`void`是『无类型』，`void*`是『无类型指针』。`void*`可以指向任何类型。
如果函数的参数可以是任意类型指针，应声明为`void*`类型：
```C++
void* memcpy(void* dest, const void* src, size_t len);
void* memset(void* buffer, int c, size_t num);
```

## 第2章 从C到C++

### 在C++中使用C
在C++中调用C代码的几种方式
```C++
// 1.在原函数声明前添加
extern "C" int Function(void);
// 2.在调用函数的C++代码中重新声明一下C函数
extern "C" int Function(void);
// 3.在包含C头文件时添加
extern "C" {
    #include "CDemo.h"
}
```

### 小心memcpy、memset、memcmp等内存操作函数
C语言的数据类型叫做POD对象（Plain Old Data）。POD对象的二进制内容是可以随意复制的，在内存中是连续的，能通过对象的基地址和数据成员的偏移量获取数据成员的地址。所以可以使用这些内存操作函数操作POD对象。
但是，C++中的对象可能不是POD，因为多态会用到虚函数表，对象的数据体中不仅有数据成员，还有虚函数表。对象的数据成员在内存中是不连续的。

### 用new/delete代替malloc/free
* new/delete，运算符。会调用构造函数和析构函数。
* malloc/free，库函数。仅实现内存的分配和释放。

### 宏尾端的注释用/**/

### 几类头文件
1. "stdio.h"，标准化以前C++中的C标准库
2. "cstdio.h"，标准化后经过改造的C标准库，用std包装，例如std::printf()
3. "iostream.h"，没有用std包装的C++"准"标准库
4. "iostream"，用std包装的C++标准库，首选

### 尽量使用C++风格的强制转型

# 第二部分 编码习惯和规范篇