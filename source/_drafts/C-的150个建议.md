---
title: C++的150个建议
date: 2019-04-05 22:29:19
updated: 2019-04-05 22:29:19
description: 读书笔记：《编写高质量代码：改善C++程序的150个建议》
categories: C++
tags:
- C++
---

读书笔记，书名：《编写高质量代码：改善C++程序的150个建议》

# 第一部分 语法篇

## 第1章 从C继承而来

### 不要让main返回void
C++03中给出的2种main函数定义方式：
```C++
int main() 
int main( int argc, char *argv[] )
```
在linux中执行`./out && echo "success"`，如果main函数`return -1`，则不会输出"success"
C++中还有个规定，如果main函数中不写return，编译器会隐式地加上`return 0`

### 区分0的4种面孔
1. 整型`0`
2. 空指针NULL，`#define NULL 0`。 C++中空指针被定义为`nullptr`
3. 字符串结束符`'\0'`
4. 逻辑`false`

### == 的正确使用方式
```C++
if (0 == value){
}
```

### 表达式的计算顺序
1. 不确定优先级时，使用括号解决
2. 不确定fun_1()与fun_2()的计算顺序
```C++
printf("The results are: %d %d", fun_1(), fun_2() );
```

### 宏#define的陷阱
1. 使用完备的括号
2. 调用宏定义函数时，不要使参数发生变化
```C++
#define SQUARE( a ) ((a) * (a)) 
int Square(int a) { return a*a; } 

int nValue1 = 10, nValue2 = 10; 
int nSquare1 = SQUARE(nValue1++);   // nSquare1=110, nValue1=12 
int nSquare2 = Square(nValue2++);   // nSquare2=100, nValue2=11
```
3. 用大括号将多条表达式括起来

### 指针必须赋初始化值
如果不赋初值，编译器会初始化一个随机值，这将是很危险的。
```C++
int* p = NULL;
int* q = new int(1);
```

### 逗号分隔符
```C++
表达式1, 表达式2, 表达式3, ..., 表达式n
```
整个逗号分隔表达式的值为`表达式n`的值。

### 时刻提防内存溢出
在处理字符串、数组时，时刻提防内存溢出。

### 拒绝晦涩难懂的函数指针

### 防止重复包含头文件
为了避免同一个文件被包含多次，C/C++中有两种处理方式，一种是#ifndef方式，另一种是#pragma once方式。
**注意：不同的头文件不能使用相同的宏名，否则编译器会报"找不到声明"的错误**
1. 方式1： 
```C++
#ifndef __SOMEFILE_H__
#define __SOMEFILE_H__
// 声明、定义语句 
#endif 
```
2. 方式2：(GCC已经取消支持，Visual Studio还支持)
```C++ 
#pragma once 
// 声明、定义语句
```

### 优化结构体中的元素布局

### 将强制转换减到最少
C++的四种强制转换形式：
1. const_cast<T*> (a)，从类中去除一下属性：const、volatile、__unaligned
2. dynamic_cast<T*> (a)，"类的安全的向下转换"，用于将基类指针转换为派生类指针，基类指针可以指向派生类对象，能实现多态，转换是安全的。
3. reinterpret_cast<T*> (a)，"重新解释"，不相关类型之间的转换，是不安全的
4. static_cast<T*> (a)，相当于传统的C语言里的强制转换，在运行时转换过程中，不进行类型检查，是不安全的
```C++
class Base {
};

class Derived : public Base {
};

int main() {

    Base *pB = new Base();
    if (Derived *pD = static_cast<Derived *>(pB)) {
        // 编译期和运行时不做类型检查
        // 向上转换是不安全的(坚决抵制这种方法)
    }

    Derived *pD = new Derived();
    if (Base *p1 = static_cast<Base *>(pD)) {
        // 向下转换是安全的
    }

    if (Derived *p2 = dynamic_cast<Derived *>(pB)) {
        // 编译期报错，error: 'Base' is not polymorphic
    }
    if (Base *p3 = dynamic_cast<Derived *>(pD)) {
        // 向下转换是安全的
    }
    return 0;
}
```

### 优先使用前缀操作符
后缀操作过程中会构造一个临时对象，因此效率不如前缀操作。
但是，对于整型和长整型而言，性能区别通常可以忽略。另外，编译器一般会对后缀操作符进行优化。

### 掌握变量定义的时机
1. 尽量不在循环内定义变量或实例化对象
2. 尽可能晚、尽可能local

### 小心typedef的陷阱
1. typedef与#define的区别
```C++
typedef int* PTR_INT1
#define PTRINT2
PTR_INT1 pNum1, pNum2;  // pNum2是int*类型
PTR_INT2 pNum3, pNum4;  // nNum4是int类型
```
2. typedef可以定义平台无关的类型，如size_t
3. typedef是一个存储类的关键字，类似于static、mutable、register等

### 尽量不要使用可变参数
可变参数的函数没有类型检查，形式如下：
```C++
int func(int para1, int para2, ...);
```

### 禁用goto

### 小心隐式转换
1. 基本类型之间的隐式转换，要注意精度损失问题。
2. C++中规定T*到void*单向的转换，是安全的。而C中允许双向转换，不安全。
3. 不明确的构造函数，不检查参数类型；转换过程中会调用类的构造函数、析构函数
编译器会隐式地将float类型的fVal转成int，然后调用类A的构造函数。
解决方法：为单参数的构造函数加上explicite关键字。
```C++
class A
{
public:
    A(int x): m_data(x){}
private:
    int m_data;
}
void DoSomething(A a);
float fVal = 1.23f;
DoSomething(fVal);
```
4. 安全的隐式转换：子类到基类的转换、const到non-const的转换

### 正确区分void与void*
`void`是『无类型』，`void*`是『无类型指针』。`void*`可以指向任何类型。
如果函数的参数可以是任意类型指针，应声明为`void*`类型：
```C++
void* memcpy(void* dest, const void* src, size_t len);
void* memset(void* buffer, int c, size_t num);
```

## 第2章 从C到C++

### 在C++中使用C
在C++中调用C代码的几种方式
```C++
// 1.在原函数声明前添加
extern "C" int Function(void);
// 2.在调用函数的C++代码中重新声明一下C函数
extern "C" int Function(void);
// 3.在包含C头文件时添加
extern "C" {
    #include "CDemo.h"
}
```

### 小心memcpy、memset、memcmp等内存操作函数
C语言的数据类型叫做POD对象（Plain Old Data）。POD对象的二进制内容是可以随意复制的，在内存中是连续的，能通过对象的基地址和数据成员的偏移量获取数据成员的地址。所以可以使用这些内存操作函数操作POD对象。
但是，C++中的对象可能不是POD，因为多态会用到虚函数表，对象的数据体中不仅有数据成员，还有虚函数表。对象的数据成员在内存中是不连续的。

### 用new/delete代替malloc/free
* new/delete，运算符。会调用构造函数和析构函数。
* malloc/free，库函数。仅实现内存的分配和释放。

### 宏尾端的注释用/**/

### 几类头文件
1. "stdio.h"，标准化以前C++中的C标准库
2. "cstdio.h"，标准化后经过改造的C标准库，用std包装，例如std::printf()
3. "iostream.h"，没有用std包装的C++"准"标准库
4. "iostream"，用std包装的C++标准库，首选

### 尽量使用C++风格的强制转型
C++风格的强制变换更安全，参考建议11

### 尽量使用const、enum、inline替换#define
从源代码到二进制文件的过程：预处理->编译->链接。宏替换在预处理阶段。
尽量将工作交给编译器，而不是预处理器。
1. 用内联函数替换宏定义函数，既可以得到宏的高效，又能保证类型安全
```C++
template <typename T>
inline T Add(const T&a, const T& b)
{
    return (a+b);
}
```
2. 常量指针与指向常量的指针：如果const出现在`*`左边，则数据为常量；如果在`*`右边，则指针为常量。
```C++
const int * p = 123;        // 指向常量的指针
int * const p = 123;        // 常指针
const int * const p = 123;  // 指向常量的长指针
```

### 用引用代替指针
引用只是对应实体的别名，引用必须初始化。
引用不占任何存储空间，因此不存在引用的引用、指向引用的指针（实质上是指向被引用实体的指针）、引用的数组。

## 第三章 内存管理
在VC中，栈空间未初始化的字符默认是-52，补码是0xCC。0xCCCC在GBK编码中就是"烫"。
堆空间未初始化的字符默认是-51，两个-51在GBK编码中就是"屯"。
### 区分内存分配的方式
程序由4部分组成：
1. 代码区，存放程序的执行代码。无法控制。
2. 数据区，存放全局数据、常量、静态变量等。自由存储区、全局/静态存储区、常量存储区。
3. 堆区，存放动态内存
4. 栈区，存放程序中用到的局部数据。
内存的5个区：
1. 栈区，存储函数内部变量，函数执行完自动释放。栈内存分配运算内置于处理器的指令集，效率很高，缺点是分配的内存容量有限。
2. 堆区，由new运算符分配的内存块，由delete释放。如果没释放，程序结束后操作系统自动回收。
3. 自由存储区，由malloc等分配的内存块，用free释放。
4. 全局/静态存储区，C的全局常量分为初始化和未初始化，C++里没区分。
5. 常量存储区，存放常量，不允许修改。

堆内存的分配效率很低，还可能引发用户态和和心态的切换。栈内存的分配效率很高。
因此要在合适的地方采用合适的内存分配方式。

### new/delete与new[]/delete[]必须配对使用
内置类型没有构造、析构函数，所以使用delete或delete[]一样。

### 区分new的三种形态
1. new operator，最常见的new运算符。
语言内建的，不能重载，也不能改变其行为。做如下三件事：
（1）分配内存（2）调用构造函数（3）返回对象的指针
2. operator new，申请原始内存。也就是new operator的第一步。与C库中的malloc函数很想。
3. placement new，选择调用哪个构造函数。也就是new operator的第二步。

三种形态的用法：
1. 如果只是想在堆上建立对象，使用new operator。
2. 如果只是想分配内存，使用operator new。
3. 如果想在已经获得的内存里建立一个对象，使用placement new。
`operator new`与`placement new`的示例：
```C++
class A{
public:
    A();
    A(int a);
    ~A();
    void* operator new(size_t size);
    void* operator new[](size_t size);
    void operator delete(void*ptr, size_t sz);
    void operator delete[](void*ptr, size_t sz);

public:
    int a;
};

A::A():a(0)
{
    cout << "construct A" << endl;
}

A::A(int a):a(a)
{
    cout << "construct A" << endl;
}
A::~A() {
    cout << "destruct A" << endl;
}

void * A::operator new(size_t sz)
{
    cout << "custom operator new for size " << sz << endl;
    return ::operator new(sz);
}
void * A::operator new[](size_t sz)
{
    cout << "custom operator new for size " << sz << endl;
    return ::operator new(sz);
}

void A::operator delete(void* ptr, size_t sz)
{
    std::cout << "custom operator delete for size " << sz << endl;
    ::operator delete(ptr);
}
void A::operator delete[](void* ptr, size_t sz)
{
    std::cout << "custom operator delete for size " << sz << endl;
    ::operator delete(ptr);
}


int main(int argv, char* args[]) {
    cout << "1. operate new" << endl;
    A *ptrA = new A(123);     // operator new for size 4
    cout << "(*ptrA).a: " << (*ptrA).a << endl;
    cout << "sizeof ptrA: " << sizeof(ptrA) << endl;    // sizeof ptrA: 8
    delete ptrA;            // custom operator delete for size 4
    cout << endl;

    size_t len = 3;
    A *ptrB = new A[len];   // custom operator new for size 20
    cout << "sizeof ptrB: " << sizeof(ptrB) << endl;    // sizeof ptrB: 8
    cout << "sizeof A: " << sizeof(A) << endl;          // sizeof A: 4
    for (size_t ik = 0; ik < len; ++ik) {
        cout << "(*(ptrB+" << ik << ")).a: " << (*(ptrB + ik)).a << endl;
    }
    delete[] ptrB;          // custom operator delete for size 20, (20=8+4*3)

    cout << "\n2. placement new" << endl;
    void* s = operator new (sizeof(A));     // 分配内存
    A* ptrC = (A*) s;
    ::new(ptrC) A(2019);                    // 调用一个参数的构造函数
    cout << "(*ptrC).a: " << (*ptrC).a << endl;
    ::new(ptrC) A();                        // 调用没有参数的构造函数
    cout << "(*ptrC).a: " << (*ptrC).a << endl;
    delete ptrC;
    return 0;
}

/* Output:
1. operate new
custom operator new for size 4
construct A
(*ptrA).a: 123
sizeof ptrA: 8
destruct A
custom operator delete for size 4

custom operator new for size 20
construct A
construct A
construct A
sizeof ptrB: 8
sizeof A: 4
(*(ptrB+0)).a: 0
(*(ptrB+1)).a: 0
(*(ptrB+2)).a: 0
destruct A
destruct A
destruct A
custom operator delete for size 20

2. placement new
construct A
(*ptrC).a: 2019
construct A
(*ptrC).a: 0
destruct A
custom operator delete for size 4
*/
```

### new内存失败后的正确处理方式
malloc函数在申请内存失败后会返回NULL。
new在申请内存失败后会抛一个异常，不会执行if(ptr == NULL){}

一般来说，new失败可能是内存不足引起的，捕获这个异常没有意义，可以直接core dump。

# 第二部分 编码习惯和规范篇